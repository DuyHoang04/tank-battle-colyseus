<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tank Battle - Multiplayer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      color: #fff;
      overflow: hidden;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    h1 {
      text-align: center;
      font-size: 3rem;
      background: linear-gradient(to right, #e94560, #f39c12, #2ecc71);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
      margin-bottom: 30px;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from {
        filter: drop-shadow(0 0 10px rgba(233, 69, 96, 0.5));
      }

      to {
        filter: drop-shadow(0 0 20px rgba(243, 156, 18, 0.5));
      }
    }

    /* Screens */
    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    /* Main Menu */
    #main-menu {
      text-align: center;
      padding-top: 50px;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 300px;
      margin: 0 auto;
    }

    input[type="text"] {
      padding: 15px 20px;
      font-size: 1.1rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      outline: none;
      transition: all 0.3s;
    }

    input[type="text"]:focus {
      border-color: #e94560;
      background: rgba(255, 255, 255, 0.15);
    }

    input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .btn {
      padding: 15px 30px;
      font-size: 1.2rem;
      font-weight: bold;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #e94560, #c13855);
      color: #fff;
      box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
    }

    .btn-primary:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px rgba(233, 69, 96, 0.6);
    }

    .btn-secondary {
      background: linear-gradient(135deg, #3498db, #2980b9);
      color: #fff;
      box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
    }

    .btn-secondary:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px rgba(52, 152, 219, 0.6);
    }

    .btn-success {
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      color: #fff;
      box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4);
    }

    .btn-success:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px rgba(46, 204, 113, 0.6);
    }

    .btn-danger {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: #fff;
      box-shadow: 0 5px 20px rgba(231, 76, 60, 0.4);
    }

    .btn-danger:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    /* Room List */
    .room-list {
      margin-top: 30px;
    }

    .room-list h3 {
      margin-bottom: 15px;
      color: #f39c12;
    }

    .room-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px 20px;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      transition: all 0.3s;
    }

    .room-item:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Lobby Screen */
    #lobby-screen {
      text-align: center;
      padding-top: 30px;
    }

    .lobby-info {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 30px;
    }

    .room-id {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 10px;
    }

    .players-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
    }

    .player-card {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      min-width: 150px;
      position: relative;
      transition: all 0.3s;
    }

    .player-card.ready {
      border: 2px solid #2ecc71;
      box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
    }

    .player-card.host::before {
      content: 'üëë';
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.5rem;
    }

    .player-name {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .player-status {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
    }

    .player-status.ready {
      color: #2ecc71;
    }

    .lobby-actions {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    /* Game Screen */
    #game-screen {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    #game-canvas {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
      cursor: crosshair;
    }

    .game-hud {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 10px;
    }

    .hud-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .hud-item:last-child {
      margin-bottom: 0;
    }

    .health-bar {
      width: 150px;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(to right, #e74c3c, #2ecc71);
      transition: width 0.3s;
    }

    .scoreboard {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 10px;
      min-width: 150px;
    }

    .scoreboard h3 {
      margin-bottom: 10px;
      color: #f39c12;
    }

    .score-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .score-item:last-child {
      border-bottom: none;
    }

    /* Game Over Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      animation: modalPop 0.3s ease-out;
    }

    @keyframes modalPop {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .modal h2 {
      font-size: 2.5rem;
      margin-bottom: 20px;
    }

    .winner-text {
      font-size: 1.5rem;
      color: #f39c12;
      margin-bottom: 30px;
    }

    .controls-help {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 0.9rem;
    }

    .controls-help h4 {
      color: #f39c12;
      margin-bottom: 10px;
    }

    .controls-help p {
      margin: 5px 0;
      color: rgba(255, 255, 255, 0.8);
    }

    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 0.8rem;
    }

    .connection-status.connected {
      background: rgba(46, 204, 113, 0.3);
      color: #2ecc71;
    }

    .connection-status.disconnected {
      background: rgba(231, 76, 60, 0.3);
      color: #e74c3c;
    }
  </style>
</head>

<body>
  <div class="connection-status disconnected" id="connection-status">Disconnected</div>

  <!-- Main Menu Screen -->
  <div id="main-menu" class="screen active">
    <div class="container">
      <h1>üéÆ Tank Battle</h1>
      <div class="menu-buttons">
        <input type="text" id="player-name" placeholder="Enter your name..." maxlength="15">
        <button class="btn btn-primary" id="btn-create">Create Room</button>
        <input type="text" id="room-id-input" placeholder="Enter Room ID...">
        <button class="btn btn-secondary" id="btn-join">Join Room</button>
      </div>
      <div class="room-list" id="room-list">
        <h3>Available Rooms</h3>
        <div id="rooms-container">
          <p style="color: rgba(255,255,255,0.5);">No rooms available. Create one!</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Lobby/Waiting Room Screen -->
  <div id="lobby-screen" class="screen">
    <div class="container">
      <h1>üéÆ Waiting Room</h1>
      <div class="lobby-info">
        <div class="room-id">Room ID: <span id="current-room-id">-</span></div>
        <div>Waiting for players... (<span id="player-count">0</span>/<span id="max-players">4</span>)</div>
      </div>
      <div class="players-list" id="players-list">
        <!-- Players will be rendered here -->
      </div>
      <div class="lobby-actions">
        <button class="btn btn-success" id="btn-ready">Ready</button>
        <button class="btn btn-primary" id="btn-start" style="display: none;">Start Game</button>
        <button class="btn btn-danger" id="btn-leave">Leave Room</button>
      </div>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen">
    <canvas id="game-canvas" width="1200" height="800"></canvas>
    <div class="game-hud">
      <div class="hud-item">
        <span>‚ù§Ô∏è Health:</span>
        <div class="health-bar">
          <div class="health-fill" id="health-fill" style="width: 100%"></div>
        </div>
      </div>
      <div class="hud-item">
        <span>üéØ Kills: <span id="kills-count">0</span></span>
      </div>
      <div class="hud-item">
        <span>‚≠ê Score: <span id="score-count">0</span></span>
      </div>
    </div>
    <div class="scoreboard">
      <h3>Scoreboard</h3>
      <div id="scoreboard-list">
        <!-- Scores will be rendered here -->
      </div>
    </div>
    <div class="controls-help">
      <h4>Controls</h4>
      <p><strong>W</strong> - Move Up</p>
      <p><strong>S</strong> - Move Down</p>
      <p><strong>A</strong> - Move Left</p>
      <p><strong>D</strong> - Move Right</p>
      <p><strong>Mouse</strong> - Aim Turret</p>
      <p><strong>Click</strong> - Fire!</p>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div class="modal" id="game-over-modal">
    <div class="modal-content">
      <h2 id="game-over-title">Game Over!</h2>
      <div class="winner-text" id="winner-text">Winner: Player 1</div>
      <div style="display: flex; gap: 15px; justify-content: center;">
        <button class="btn btn-primary" id="btn-rematch">Rematch</button>
        <button class="btn btn-danger" id="btn-exit">Exit</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/colyseus.js@0.16.0/dist/colyseus.js"></script>
  <script>
    // ==================== GAME STATE ====================
    const client = new Colyseus.Client('ws://localhost:2567');
    let room = null;
    let playerName = '';
    let mySessionId = '';
    let isHost = false;

    // Input state
    const inputState = {
      left: false,
      right: false,
      up: false,
      down: false,
      turretAngle: 0,
      shooting: false
    };

    // Game rendering
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    let gameState = null;
    let animationFrameId = null;

    // ==================== DOM ELEMENTS ====================
    const screens = {
      mainMenu: document.getElementById('main-menu'),
      lobby: document.getElementById('lobby-screen'),
      game: document.getElementById('game-screen')
    };

    const elements = {
      connectionStatus: document.getElementById('connection-status'),
      playerNameInput: document.getElementById('player-name'),
      roomIdInput: document.getElementById('room-id-input'),
      btnCreate: document.getElementById('btn-create'),
      btnJoin: document.getElementById('btn-join'),
      roomsContainer: document.getElementById('rooms-container'),
      currentRoomId: document.getElementById('current-room-id'),
      playerCount: document.getElementById('player-count'),
      maxPlayers: document.getElementById('max-players'),
      playersList: document.getElementById('players-list'),
      btnReady: document.getElementById('btn-ready'),
      btnStart: document.getElementById('btn-start'),
      btnLeave: document.getElementById('btn-leave'),
      healthFill: document.getElementById('health-fill'),
      killsCount: document.getElementById('kills-count'),
      scoreCount: document.getElementById('score-count'),
      scoreboardList: document.getElementById('scoreboard-list'),
      gameOverModal: document.getElementById('game-over-modal'),
      gameOverTitle: document.getElementById('game-over-title'),
      winnerText: document.getElementById('winner-text'),
      btnRematch: document.getElementById('btn-rematch'),
      btnExit: document.getElementById('btn-exit')
    };

    // ==================== SCREEN MANAGEMENT ====================
    function showScreen(screenName) {
      Object.values(screens).forEach(s => s.classList.remove('active'));
      screens[screenName].classList.add('active');
    }

    // ==================== ROOM MANAGEMENT ====================
    async function createRoom() {
      playerName = elements.playerNameInput.value.trim() || 'Player';
      try {
        room = await client.create('tank_battle', { name: playerName });
        setupRoomListeners();
        mySessionId = room.sessionId;
        showScreen('lobby');
        updateConnectionStatus(true);
      } catch (e) {
        console.error('Failed to create room:', e);
        alert('Failed to create room!');
      }
    }

    async function joinRoom(roomId) {
      playerName = elements.playerNameInput.value.trim() || 'Player';
      const targetRoomId = roomId || elements.roomIdInput.value.trim();
      if (!targetRoomId) {
        alert('Please enter a Room ID!');
        return;
      }
      try {
        room = await client.joinById(targetRoomId, { name: playerName });
        setupRoomListeners();
        mySessionId = room.sessionId;
        showScreen('lobby');
        updateConnectionStatus(true);
      } catch (e) {
        console.error('Failed to join room:', e);
        alert('Failed to join room! Room may not exist.');
      }
    }

    function leaveRoom() {
      if (room) {
        room.leave();
        room = null;
      }
      showScreen('mainMenu');
      updateConnectionStatus(false);
      elements.gameOverModal.classList.remove('active');
    }

    function setupRoomListeners() {
      elements.currentRoomId.textContent = room.roomId;

      room.onStateChange((state) => {
        gameState = state;
        updateUI();
      });

      room.onLeave((code) => {
        console.log('Left room with code:', code);
        leaveRoom();
      });

      room.onError((code, message) => {
        console.error('Room error:', code, message);
      });
    }

    // ==================== UI UPDATES ====================
    function updateConnectionStatus(connected) {
      elements.connectionStatus.textContent = connected ? 'Connected' : 'Disconnected';
      elements.connectionStatus.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
    }

    function updateUI() {
      if (!gameState) return;

      // Update based on game phase
      if (gameState.phase === 'lobby') {
        if (!screens.lobby.classList.contains('active')) {
          showScreen('lobby');
          elements.gameOverModal.classList.remove('active');
        }
        updateLobbyUI();
      } else if (gameState.phase === 'playing') {
        if (!screens.game.classList.contains('active')) {
          showScreen('game');
          startGameLoop();
        }
        updateGameUI();
      } else if (gameState.phase === 'ended') {
        showGameOver();
      }
    }

    function updateLobbyUI() {
      isHost = gameState.hostId === mySessionId;

      // Player count
      elements.playerCount.textContent = gameState.players.size;
      elements.maxPlayers.textContent = gameState.maxPlayers;

      // Players list
      let playersHtml = '';
      gameState.players.forEach((player, sessionId) => {
        const isCurrentPlayer = sessionId === mySessionId;
        const isPlayerHost = sessionId === gameState.hostId;
        playersHtml += `
          <div class="player-card ${player.isReady ? 'ready' : ''} ${isPlayerHost ? 'host' : ''}">
            <div class="player-name" style="color: ${player.color}">${player.name} ${isCurrentPlayer ? '(You)' : ''}</div>
            <div class="player-status ${player.isReady ? 'ready' : ''}">${player.isReady ? '‚úì Ready' : 'Not Ready'}</div>
          </div>
        `;
      });
      elements.playersList.innerHTML = playersHtml;

      // Show/hide start button for host
      elements.btnStart.style.display = isHost ? 'inline-block' : 'none';
      elements.btnStart.disabled = gameState.players.size < gameState.minPlayersToStart;

      // Update ready button text
      const myPlayer = gameState.players.get(mySessionId);
      if (myPlayer) {
        elements.btnReady.textContent = myPlayer.isReady ? 'Not Ready' : 'Ready';
        elements.btnReady.className = `btn ${myPlayer.isReady ? 'btn-secondary' : 'btn-success'}`;
      }
    }

    function updateGameUI() {
      const myPlayer = gameState.players.get(mySessionId);
      if (myPlayer) {
        elements.healthFill.style.width = `${(myPlayer.health / myPlayer.maxHealth) * 100}%`;
        elements.killsCount.textContent = myPlayer.kills;
        elements.scoreCount.textContent = myPlayer.score;
      }

      // Update scoreboard
      let scoreHtml = '';
      const sortedPlayers = Array.from(gameState.players.values()).sort((a, b) => b.score - a.score);
      sortedPlayers.forEach(player => {
        scoreHtml += `
          <div class="score-item" style="color: ${player.color}; opacity: ${player.isAlive ? 1 : 0.5}">
            <span>${player.name}</span>
            <span>${player.score}</span>
          </div>
        `;
      });
      elements.scoreboardList.innerHTML = scoreHtml;
    }

    function showGameOver() {
      if (gameState.winnerId === mySessionId) {
        elements.gameOverTitle.textContent = 'üèÜ Victory!';
        elements.gameOverTitle.style.color = '#2ecc71';
      } else {
        elements.gameOverTitle.textContent = 'üíÄ Defeated';
        elements.gameOverTitle.style.color = '#e74c3c';
      }
      elements.winnerText.textContent = `Winner: ${gameState.winnerName || 'No one'}`;
      elements.gameOverModal.classList.add('active');

      // Show/hide rematch button for host
      elements.btnRematch.style.display = isHost ? 'inline-block' : 'none';
    }

    // ==================== GAME LOOP ====================
    function startGameLoop() {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      gameLoop();
    }

    function gameLoop() {
      if (gameState && gameState.phase === 'playing') {
        render();
        sendInput();
      }
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function render() {
      // Clear canvas
      ctx.fillStyle = '#2c3e50';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw bullets
      if (gameState.bullets) {
        gameState.bullets.forEach(bullet => {
          ctx.save();
          ctx.translate(bullet.x, bullet.y);
          ctx.rotate(bullet.angle);

          // Bullet trail
          const gradient = ctx.createLinearGradient(-15, 0, 10, 0);
          gradient.addColorStop(0, 'rgba(255,200,50,0)');
          gradient.addColorStop(1, 'rgba(255,200,50,1)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI * 2);
          ctx.fill();

          // Bullet core
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(5, 0, 4, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        });
      }

      // Draw tanks
      gameState.players.forEach((player, sessionId) => {
        if (!player.isAlive) return;

        ctx.save();
        ctx.translate(player.x, player.y);

        // Tank body
        ctx.rotate(player.angle);
        ctx.fillStyle = player.color;
        ctx.shadowColor = player.color;
        ctx.shadowBlur = 15;

        // Tank body shape
        ctx.beginPath();
        ctx.roundRect(-25, -20, 50, 40, 5);
        ctx.fill();

        // Tank tracks
        ctx.fillStyle = '#333';
        ctx.fillRect(-28, -22, 8, 44);
        ctx.fillRect(20, -22, 8, 44);

        ctx.rotate(-player.angle);
        ctx.shadowBlur = 0;

        // Turret
        ctx.rotate(player.turretAngle);
        ctx.fillStyle = shadeColor(player.color, -20);
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI * 2);
        ctx.fill();

        // Barrel
        ctx.fillStyle = '#333';
        ctx.fillRect(10, -4, 35, 8);
        ctx.fillStyle = shadeColor(player.color, -30);
        ctx.fillRect(10, -3, 35, 6);

        ctx.restore();

        // Health bar
        const healthPercent = player.health / player.maxHealth;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(player.x - 25, player.y - 40, 50, 8);
        ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(player.x - 25, player.y - 40, 50 * healthPercent, 8);

        // Name tag
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(player.name, player.x, player.y - 48);
      });
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }

    function sendInput() {
      if (room && gameState && gameState.phase === 'playing') {
        room.send('input', inputState);
      }
    }

    // ==================== INPUT HANDLING ====================
    document.addEventListener('keydown', (e) => {
      switch (e.key.toLowerCase()) {
        case 'w': inputState.up = true; break;
        case 's': inputState.down = true; break;
        case 'a': inputState.left = true; break;
        case 'd': inputState.right = true; break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.key.toLowerCase()) {
        case 'w': inputState.up = false; break;
        case 's': inputState.down = false; break;
        case 'a': inputState.left = false; break;
        case 'd': inputState.right = false; break;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const myPlayer = gameState?.players.get(mySessionId);
      if (myPlayer) {
        inputState.turretAngle = Math.atan2(mouseY - myPlayer.y, mouseX - myPlayer.x);
      }
    });

    canvas.addEventListener('mousedown', () => {
      inputState.shooting = true;
    });

    canvas.addEventListener('mouseup', () => {
      inputState.shooting = false;
    });

    canvas.addEventListener('mouseleave', () => {
      inputState.shooting = false;
    });

    // ==================== BUTTON HANDLERS ====================
    elements.btnCreate.addEventListener('click', createRoom);
    elements.btnJoin.addEventListener('click', () => joinRoom());
    elements.btnReady.addEventListener('click', () => room?.send('ready'));
    elements.btnStart.addEventListener('click', () => room?.send('start'));
    elements.btnLeave.addEventListener('click', leaveRoom);
    elements.btnRematch.addEventListener('click', () => room?.send('rematch'));
    elements.btnExit.addEventListener('click', leaveRoom);

    // Allow joining by pressing Enter in room ID input
    elements.roomIdInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinRoom();
    });

    // Fetch available rooms periodically
    async function fetchRooms() {
      try {
        const rooms = await client.getAvailableRooms('tank_battle');
        if (rooms.length === 0) {
          elements.roomsContainer.innerHTML = '<p style="color: rgba(255,255,255,0.5);">No rooms available. Create one!</p>';
        } else {
          let html = '';
          rooms.forEach(r => {
            html += `
              <div class="room-item">
                <span>Room ${r.roomId.slice(0, 8)}... (${r.clients}/${r.maxClients})</span>
                <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 0.9rem;" onclick="joinRoom('${r.roomId}')">Join</button>
              </div>
            `;
          });
          elements.roomsContainer.innerHTML = html;
        }
      } catch (e) {
        console.error('Failed to fetch rooms:', e);
      }
    }

    // Fetch rooms every 3 seconds when on main menu
    setInterval(() => {
      if (screens.mainMenu.classList.contains('active')) {
        fetchRooms();
      }
    }, 3000);
    fetchRooms();

    console.log('Tank Battle client initialized!');
  </script>
</body>

</html>